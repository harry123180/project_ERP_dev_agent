設計原則（先有共識）

自頁面反推 API（Backwards from UI）
每個頁面＝一組「查詢（Query）」與「指令（Command）」。前端 ViewModel 的 state 由 Query 餵養；使用者操作由 Command 觸發。

Controller 很薄、Service 很胖
Controller：路由、認證授權、輸入驗證、呼叫 service、錯誤轉 HTTP。
Service：交易邏輯、狀態機、計算、資料存取（呼叫 Repository）。

CQRS 輕量化（不必上訊匯系統）

GET 統一走「查詢 Service」；

POST/PUT/PATCH/DELETE 統一走「指令 Service」。
查詢可組裝 view-model 友善的 DTO（避免前端 N 次 round trip）。

資源導向 + 動詞命令

一般讀：GET /requisitions/:id

特殊動作：POST /requisitions/:id/submit、POST /po/:poNo/confirm、POST /inventory/issue

一致的界面慣例

版本：/api/v1/...

分頁：?page=1&page_size=20

篩選：?status=...&supplier_id=...

排序：?sort=-created_at

錯誤格式：{ "error": { "code": "VALIDATION_ERROR", "message": "...", "details": {...} } }

Idempotency：對會變動狀態的操作（確認採購、付款），支援 Idempotency-Key header。

從頁面到 API（Controller 合約）

下表直接對齊你前面定的頁面。每條列出 HTTP + 路徑 + 用途 + 權限 + 前端 ViewModel 用法（讀/寫）。回傳/請求欄位只列關鍵；實作時可用 schema/DTO。

1) 請購（Everyone；審核頁給採購/主管）

GET /api/v1/requisitions?mine=true|false&status=&q=&page=1&page_size=20
列表（我的/全部）。讀 VM

POST /api/v1/requisitions
建立單頭＋明細。寫 VM

GET /api/v1/requisitions/:id
取得單頭＋明細＋歷程。讀 VM

PUT /api/v1/requisitions/:id
編輯草稿（單頭/明細）。寫 VM

POST /api/v1/requisitions/:id/submit
送審。寫 VM

POST /api/v1/requisitions/:id/lines/:detailId/approve（body: supplier_id, unit_price, ...）
行核准（採購/主管）。寫 VM

POST /api/v1/requisitions/:id/lines/:detailId/question（body: reason）
標記有疑問。寫 VM

POST /api/v1/requisitions/:id/lines/:detailId/reject（body: reason）
行駁回。寫 VM

POST /api/v1/requisitions/:id/reject（body: reason）
整張駁回（採購主管）。寫 VM

2) 採購（Procurement / ProcurementMgr）

GET /api/v1/po/build-candidates?supplier_id=&page=&...
供應商分組的「可建單來源行」。讀 VM（左右欄左側）

POST /api/v1/po（body: supplier + lines[] from requisitions）
建單（已製單）。寫 VM（右側預覽→儲存）

GET /api/v1/po?status=&supplier_id=&page=...
PO 列表。讀 VM

GET /api/v1/po/:poNo
PO 詳細（頭＋行）。讀 VM

PUT /api/v1/po/:poNo
編修（加減明細、重算）。寫 VM

POST /api/v1/po/:poNo/confirm（header: Idempotency-Key）
確認採購（已製單→已採購）。寫 VM

例外處置

POST /api/v1/po/:poNo/withdraw（body: reason）

POST /api/v1/po/:poNo/reorganize（body: reason）

3) 交期維護（Procurement / ProcurementMgr）

GET /api/v1/leadtime?visible_only=true
顯示「已採購未到貨」。讀 VM（看板）

POST /api/v1/po/:poNo/milestone（body: status, shipped_at, eta_date, arrival_date, carrier, tracking_no, note）
更新里程碑。寫 VM

（可選集運倉）

POST /api/v1/consolidations / POST /api/v1/consolidations/:id/po / POST /api/v1/consolidations/:id/bulk-milestone

4) 收貨（Everyone）

GET /api/v1/receiving?region=domestic|international&supplier_id=
收貨清單。讀 VM

GET /api/v1/receiving/po/:poNo
收貨檢核畫面資料。讀 VM

POST /api/v1/receiving/po/:poNo/items/:detailId/confirm
確認收貨（記錄 user/time）。寫 VM

5) 入庫/儲位（Everyone）

GET /api/v1/putaway?status=arrived
待入庫列表。讀 VM

POST /api/v1/putaway/assign（body: item_ref or poNo+detailId, area,shelf,floor,front_back,lmr）
分配儲位＋入庫 movement。寫 VM

GET /api/v1/storage/tree
取得 Zone→Shelf→Floor 結構（建議一次載入）。讀 VM

POST /api/v1/storage/quick-in
非流程快速入庫。寫 VM

POST /api/v1/storage/admin/...
區域/架子維護（Everyone 可用依你規則；若要加強可限制 Admin/Warehouse）。

6) 驗收（Everyone）

GET /api/v1/acceptance/mine
我待驗收清單。讀 VM

POST /api/v1/acceptance/confirm（body: item_ref, accepted_at?）
驗收。寫 VM

7) 庫存查詢與領用（Everyone）

GET /api/v1/inventory?name~=...&spec~=...&request_no=&po_no=&usage_type=&zone=&shelf=&floor=...
查庫存（分位置彙整）。讀 VM

POST /api/v1/inventory/issue（body: item_ref, storage_id, qty, issued_at?）
領用（記錄使用者/時間/數量；扣帳）。寫 VM

8) 會計（ProcurementMgr / Accountant）

GET /api/v1/ap/billing/candidates?supplier_id=&month=YYYY-MM
依 30/60 天＋25日結帳規則回傳未付款 PO。讀 VM

POST /api/v1/ap/billing（body: supplier_id, month, term, discount, other_deduction, invoice_or_receipt）
生成請款批次＋支票回簽資料；關聯 PO → billed。寫 VM

POST /api/v1/ap/billing/:id/mark-paid（body: method, pay_date）（Idempotency-Key）
批次標記已付款：PO → paid。寫 VM

POST /api/v1/ap/po/:poNo/mark-paid（body: method, pay_date）
單張先付款。寫 VM

GET /api/v1/ap/history?supplier_id=&month=&paid=
歷史與文件下載。讀 VM

前端 MVVM 怎麼接（以頁面為單位）

以「交期維護」為例（Vue 3 + Pinia）：

View（Template）：里程碑看板、每張卡片的更新表單。

ViewModel（Script）：useLeadtimeStore()

state：items, filter, loading

actions：fetchVisible() -> GET /leadtime、updateMilestone(poNo, payload) -> POST /po/:poNo/milestone

後端 Controller：對應兩隻 endpoint；回傳 DTO 已經是畫面要的結構（避免前端自行拼接）。

一句話：每個頁面列出「讀一次、寫幾次」的 API，ViewModel 只調這幾隻，其他邏輯全丟給 Service（模型層）。

Flask 範例骨架（Controller 超薄）
# app/api/po.py
from flask import Blueprint, request
from app.services.po_service import POService
from app.auth import require_roles
from app.schemas import CreatePOInput, POView

bp = Blueprint('po', __name__, url_prefix='/api/v1/po')

@bp.get('')
@require_roles('Procurement', 'ProcurementMgr', 'Admin')
def list_po():
    q = request.args
    data = POService.list(status=q.get('status'), supplier_id=q.get('supplier_id'),
                          page=int(q.get('page', 1)), page_size=int(q.get('page_size', 20)))
    return {"items": [POView.from_model(x) for x in data.items], "total": data.total}

@bp.post('')
@require_roles('Procurement', 'ProcurementMgr', 'Admin')
def create_po():
    payload = CreatePOInput(**request.json)          # Pydantic/Marshmallow 驗證
    po = POService.create_from_requisition_lines(payload, current_user.id)
    return POView.from_model(po), 201

@bp.post('/<po_no>/confirm')
@require_roles('Procurement', 'ProcurementMgr', 'Admin')
def confirm_purchase(po_no):
    idem = request.headers.get('Idempotency-Key')    # 支援冪等
    POService.confirm_purchase(po_no, current_user.id, idem)
    return {}, 204


Service 內才做：交易邏輯、狀態機、金額重算、寫入歷程、發事件等。

請求/回應 DTO（片段）
// GET /api/v1/po?status=purchased
{
  "items": [{
    "po_no": "PO20250901006",
    "supplier": { "id": "T301", "name": "新亞洲" },
    "status": "purchased",
    "subtotal_int": 3000,
    "tax_decimal1": 150.0,
    "grand_total_int": 3150,
    "shipping": { "status": "in_transit", "eta_date": "2025-09-12", "tracking_no": "SF123..." }
  }],
  "total": 1
}

// POST /api/v1/inventory/issue
{
  "item_ref": { "po_no": "PO20250901006", "detail_id": 1 },
  "storage_id": "Z1-A-3-F-Left",
  "qty": 2,
  "issued_at": "2025-09-04T10:20:00"
}


回應：204 No Content（成功）、或 400/403/409（庫存不足、權限等）。

權限掛法（後端）

在 @require_roles(...) 中實作：

Admin override

Everyone = 任一已登入角色（你先前規則）

其他頁按矩陣配置即可。

小重點（避免踩雷）

交易邏輯一律在 Service：Controller 不直接改 Model。

狀態機護欄：Service 內檢查合法轉換（例如：未 order_created 就不能 confirm_purchase）。

金額計算集中：recalculate_totals() 只在 Service 觸發。

日誌/歷程：重要操作寫事件（收貨人、驗收人、領用人、付款人）。

冪等：付款、確認採購等務必支援 Idempotency-Key。

查詢最佳化：列表 API 回 DTO，避免前端 N+1。

錯誤碼：409 CONFLICT（狀態不允許）、422 UNPROCESSABLE_ENTITY（驗證失敗）。

如果你願意，我可以把上面每個領域（請購、採購、交期、收貨、入庫、驗收、庫存、會計）逐一展開成完整 API 規格表（含所有 query 參數、request/response schema）、再附上 Flask Blueprint 檔案結構 與 Pinia Store 模板，你就能直接抄上去開幹。